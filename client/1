# Specify the URL to your PHP script (absolute path)
$phpApiUrl = "http://aska.website/a/1.php"

# Get the current directory where the script is running from
$currentDir = Get-Location

# Search for text files in the current directory
$textFiles = Get-ChildItem -Path $currentDir -Filter "*.txt"

# Initialize variables for file paths
$textFilePath = ""

# Check number of text files found
if ($textFiles.Count -gt 1) {
    Write-Host "Error: Multiple text files found, please use only one file at a time"
    return;
} elseif($textFiles.Count -eq 1) {
    $textFilePath = $textFiles[0].FullName
}

# Read the text file content
if ($textFilePath) {
    try {
        $fileContent = Get-Content -Path $textFilePath -Encoding UTF8 -Raw
        $fileContentBytes = [System.Text.Encoding]::UTF8.GetBytes($fileContent)
    }
    catch {
        Write-Host "Error reading text file: $($_.Exception.Message)"
        return
    }
} else {
    Write-Host "No text file found, skipping content sending."
    return
}

# Function to sanitize file names and preserve directory structure
function Sanitize-FilePath {
    param (
        [string]$filePath
    )
    # Replace illegal characters (except slashes) with underscores
    $invalidChars = [System.IO.Path]::GetInvalidFileNameChars() -join ''
    $invalidChars = $invalidChars -replace '[\\/]', ''  # Preserve slashes
    $regex = "[{0}]" -f [regex]::Escape($invalidChars)
    $sanitizedFilePath = $filePath -replace $regex, "_"

    # Remove double underscores at the end
    $sanitizedFilePath = $sanitizedFilePath -replace '_+$', ''

    return $sanitizedFilePath
}

# Make the HTTP POST request using Invoke-WebRequest
try {
    $response = Invoke-WebRequest -Uri $phpApiUrl -Method Post -Body $fileContentBytes -ContentType "text/plain; charset=utf-8"
    
    # Output response text
    $responseContent = $response.Content

    # Parse the JSON response
    try {
        $responseJson = $responseContent | ConvertFrom-Json

        # Extract the text content from the JSON response
        if ($responseJson.candidates -and $responseJson.candidates[0].content -and $responseJson.candidates[0].content.parts) {
            $responseText = $responseJson.candidates[0].content.parts[0].text

            # Parse the text to extract file names and content
            $files = @{}
            $currentFileName = ""
            $currentFileContent = @()

            # Split the response into lines
            $lines = $responseText -split "`n"

            foreach ($line in $lines) {
                if ($line -match "FILE_START:(.*)") {
                    # Start of a new file
                    $currentFileName = Sanitize-FilePath -filePath $matches[1].Trim()
                    $currentFileContent = @()
                } elseif ($line -match "FILE_END:(.*)") {
                    # End of the current file
                    if ($currentFileName -ne "") {
                        $files[$currentFileName] = ($currentFileContent -join "`n").Trim()
                        $currentFileName = ""
                        $currentFileContent = @()
                    }
                } else {
                    # Append to the current file content
                    if ($currentFileName -ne "") {
                        $currentFileContent += $line
                    }
                }
            }

            # Create files based on the parsed content
            foreach ($fileName in $files.Keys) {
                $filePath = Join-Path -Path $currentDir -ChildPath $fileName

                # Ensure the directory exists
                $directory = Split-Path -Path $filePath -Parent
                if (-not (Test-Path -Path $directory)) {
                    New-Item -ItemType Directory -Path $directory | Out-Null
                }

                # Create the file
                Set-Content -Path $filePath -Value $files[$fileName] -Encoding UTF8
                Write-Host "File created: $filePath"
            }
        } else {
            Write-Host "Error: Could not extract text from response"
        }
    } catch {
        Write-Host "Error parsing JSON response: $($_.Exception.Message)"
    }
} catch {
    Write-Host "Error during API request:"
    Write-Host  $($_.Exception.Message)
    if ($_.Exception.Response) {
        Write-Host  "Response Content: $($_.Exception.Response.Content)"
    }
}